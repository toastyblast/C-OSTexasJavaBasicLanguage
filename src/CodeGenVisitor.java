import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.TerminalNode;

import java.util.ArrayList;
import java.util.List;

/**
 * Code generator for the TJ-B language compiler. Returns an ArrayList of Strings which are the generated code.
 * The input is a decorated parse tree made by the type checker from a text file with code of the TJ-B grammar.
 * This is visited node by node by the code generator and the nodes are turned into the correct Jasmin/Java ByteCode.
 * That can then be used to create a Java class file that can be executed (This project does that automatically upon runtime).
 *
 * Throughout one might see the usage of duplicate suppressors. This is so that IntelliJ stops whining. In a code
 * generator you simply can't define methods well to share a bit of code without causing issues, so to prevent
 * annoyance we stop the warnings.
 *
 * Made for Saxion's HBO-IT (International) course "Compilers & Operating systems" (Y2Q3 ~ 2017-2018).
 * @author Yoran Kerbusch & Martin S. Slavov.
 */
public class CodeGenVisitor extends TJBBaseVisitor<ArrayList<String>> {
    private Singleton singleton = Singleton.getInstance();

    private final ArrayList<String> variables = new ArrayList<>();
    private int compSequence = 0;
    private int forSequence = 0;
    private int whileSequence = 0;
    private int ifSequence = 0;
    private int orLogicSequence = 0;
    private int andLogicSequence = 0;

    private int localCurrentIf = 0;
    private int currentElseIf = 0;

    public CodeGenVisitor() {
        //Empty constructor, nothing needed.
    }

    /**
     * Visitor of the root node of the whole parse tree. Adds all the generated code plus the stack sizes.
     *
     * @param ctx CodeLineContext is the context of this root node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitCodeLine(TJBParser.CodeLineContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Add all the code from all the children nodes to your output, since you're the last return.
        for (TJBParser.ExpressionContext expression : ctx.expression()) {
            code.addAll(visit(expression));
        }

        //Add the stack and locals sizes to the top of the code so Jasmin knows how much memory to allocated.
        // The locals size is precise up to how many variables were declared, whereas the stack is a spacious guess.
        //Change the number at the ".limit stack 64" to change the stack size if you're having issues with this.
        code.add(0, "\t.limit\tstack\t64");
        code.add(1, "\t.limit\tlocals\t" + (variables.size() + 1) + "\n");

        return code;
    }

    /**
     * This visitor is for when a new integer or double variable is first declared.
     *
     * "2784 -> A"
     * OR
     * "5.501 -> B"
     *
     * @param ctx NumAsnContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @SuppressWarnings("Duplicates")
    @Override
    public ArrayList<String> visitNumAsn(TJBParser.NumAsnContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Due to the typechecker we're always sure this variable is new and we do not have to check if it already exists.
        String numID = ctx.name.getText();
        variables.add(numID);
        int indexOffset = variables.size();

        code.addAll(visit(ctx.calculation()));

        //Now check the type to know if we need to add code to store an integer or a double onto locals for Jasmin.
        Type type = singleton.getCheckUpTable().get(ctx).getType();
        switch (type) {
            case INT:
                code.add("\tistore\t" + indexOffset + "\n");
                break;
            case DOUBLE:
                code.add("\tfstore\t" + indexOffset + "\n");
                break;
        }

        return code;
    }

    /**
     * This visitor is for when a new String is first assigned to an empty String variable.
     *
     * ""Hello world" -> Str1"
     *
     * @param ctx StrAsnContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitStrAsn(TJBParser.StrAsnContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Add the string to the variables ArrayList so we know later where to store or load from if this variable is called
        String strID = ctx.name.getText();
        variables.add(strID);
        int indexOffset = variables.size();

        //Load the string given and put it on the locals stack.
        code.add("\tldc\t" + ctx.value.getText());
        code.add("\tastore\t" + indexOffset + "\n");

        return code;
    }

    /**
     * Visitor for when a new Array is created and values assigned to.
     *
     * @param ctx ArrAsnContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitArrAsn(TJBParser.ArrAsnContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Add the array to the variables ArrayList so we know where to store it now and store/load it from later.
        String arrID = ctx.name.getText();
        variables.add(arrID);
        int indexOffset = variables.size();

        List<ParseTree> terminalNodes = new ArrayList<>();

        for (int i = 0; i < ctx.value.getChildCount(); i++) {
            if (!ctx.value.getChild(i).getText().equals("{") &&
                    !ctx.value.getChild(i).getText().equals("}") &&
                    !ctx.value.getChild(i).getText().equals(",")) {
                terminalNodes.add(ctx.value.getChild(i));
            }
        }

        Type type = singleton.getCheckUpTable().get(ctx).getType();
        code.add("\tldc\t" + terminalNodes.size());

        switch (type) {
            case INTARRAY:
                code.add("\tnewarray\tint");
                code.add("\tastore\t" + indexOffset + "\n");

                for (int i = 0; i < terminalNodes.size(); i++) {
                    code.add("\taload\t" + indexOffset);
                    code.add("\tldc\t" + i);

                    if (terminalNodes.get(i) instanceof TerminalNode) {
                        code.add("\tldc\t" + terminalNodes.get(i).getText());
                    } else if (terminalNodes.get(i) instanceof TJBParser.CalculationContext) {

                        if (terminalNodes.get(i).getChild(0) instanceof TJBParser.CheckVARContext) {
                            code.add("\tiload\t" + (variables.indexOf(terminalNodes.get(i).getChild(0).getText()) + 1));
                        } else {
                            code.addAll(visit(terminalNodes.get(i)));
                        }
                    }

                    code.add("\tiastore\n");
                }

                break;
            case DOUBLEARRAY:
                code.add("\tnewarray\tfloat");
                code.add("\tastore\t" + indexOffset + "\n");

                for (int i = 0; i < terminalNodes.size(); i++) {
                    code.add("\taload\t" + indexOffset);
                    code.add("\tldc\t" + i);

                    if (terminalNodes.get(i) instanceof TerminalNode) {
                        code.add("\tldc\t" + terminalNodes.get(i).getText());

                        if (!terminalNodes.get(i).getText().contains(".")) {
                            code.add("\ti2f");
                        }
                    } else if (terminalNodes.get(i) instanceof TJBParser.CalculationContext) {

                        if (terminalNodes.get(i).getChild(0) instanceof TJBParser.CheckVARContext) {
                            Symbol symbol = singleton.getSymbolTable().getSymTable().get(terminalNodes.get(i).getChild(0).getText());
                            code.add("\tiload\t" + (variables.indexOf(terminalNodes.get(i).getChild(0).getText()) + 1));

                            if (symbol.getType() == Type.INT) {
                                code.add("\ti2f");
                            }
                        } else {
                            Type type1 = singleton.getCheckUpTable().get(terminalNodes.get(i)).getType();
                            code.addAll(visit(terminalNodes.get(i)));

                            if (type1 == Type.INT) {
                                code.add("\ti2f");
                            }
                        }
                    }

                    code.add("\tfastore\n");
                }

                break;
            case STRINGARRAY:
                code.add("\tanewarray\tjava/lang/String");
                code.add("\tastore\t" + indexOffset + "\n");

                for (int i = 0; i < terminalNodes.size(); i++) {
                    code.add("\taload\t" + indexOffset);
                    code.add("\tldc\t" + i);

                    if (terminalNodes.get(i) instanceof TerminalNode) {
                        code.add("\tldc\t" + terminalNodes.get(i).getText());
                    } else if (terminalNodes.get(i) instanceof TJBParser.CheckSTRIDContext) {
                        code.add("\taload\t" + (variables.indexOf(terminalNodes.get(i).getChild(0).getText()) + 1));
                    }

                    code.add("\taastore\n");
                }

                break;
        }

        return code;
    }

    /**
     * Visitor for when a new String variable is declared by using the value from an already existing String variable.
     *
     * ""Hello world" -> Str1"
     * "Str1 -> Str2"
     *
     * @param ctx StrCpyAsnContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitStrCpyAsn(TJBParser.StrCpyAsnContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Get the index in the locals of the string to copy the value of.
        String strID = ctx.name.getText();
        int copyOffset = singleton.getCheckUpTable().get(ctx.value).getNumberOnStack();

        //Add the new string to the locals stack and get its given ID.
        variables.add(strID);
        int indexOffset = variables.size();

        //Get the value from the requested string's local slot.
        code.add("\taload\t" + copyOffset);
        //Store it on this new variable's local slot.
        code.add("\tastore\t" + indexOffset + "\n");

        return code;
    }

    @Override
    public ArrayList<String> visitArrCpyAsn(TJBParser.ArrCpyAsnContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        String arrID = ctx.name.getText();

        int copyOffset = singleton.getCheckUpTable().get(ctx.value).getNumberOnStack();

        variables.add(arrID);
        int indexOffset = singleton.getCheckUpTable().get(ctx.name).getNumberOnStack();

        code.add("\taload " + copyOffset);
        code.add("\tastore " + indexOffset);

        return code;
    }

    /**
     * Visitor for when a new number is added to an already defined number variable.
     *
     * "612 --> A"
     * OR
     * "23.6 --> B"
     *
     * @param ctx NumAsnVARContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @SuppressWarnings("Duplicates")
    @Override
    public ArrayList<String> visitNumAsnVAR(TJBParser.NumAsnVARContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Get the number on the locals of the variable we're overriding.
        int indexOffset = singleton.getCheckUpTable().get(ctx.name).getNumberOnStack();

        code.addAll(visit(ctx.calculation()));

        //Check if the variable we're putting a new number into is an integer or a double (float) to load the right code.
        Type type = singleton.getCheckUpTable().get(ctx).getType();
        switch (type) {
            case INT:
                code.add("\tistore\t" + indexOffset + "\n");
                break;
            case DOUBLE:
                code.add("\tfstore\t" + indexOffset + "\n");
                break;
        }

        return code;
    }

    /**
     * Visitor for when you want to put a new string into an already existing string variable.
     *
     * ""Spam egg" --> Str1"
     *
     * @param ctx StrAsnNEWVARContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitStrAsnNEWVAR(TJBParser.StrAsnNEWVARContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Find the location of the already defined string on the locals stack
        int indexOffset = singleton.getCheckUpTable().get(ctx.name).getNumberOnStack();

        //Override the location with the new String.
        code.add("\tldc\t" + ctx.value.getText());
        code.add("\tastore\t" + indexOffset + "\n");

        return code;
    }

    /**
     * Visitor for when an already existing string variable has its value changed by copying another string variable
     *
     * "Str1 --> Str2"
     *
     * @param ctx StrAsnVARContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitStrAsnVAR(TJBParser.StrAsnVARContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Get the index of the string we want to load onto from the locals stack.
        int indexOffset = singleton.getCheckUpTable().get(ctx.name).getNumberOnStack();

        //Also get the index on the locals stack of the one we want to copy deom
        int copyIndexOffset = singleton.getCheckUpTable().get(ctx.value).getNumberOnStack();

        //Then add the coad to load the one string from locals and store it in the other.
        code.add("\taload\t" + copyIndexOffset);
        code.add("\tastore\t" + indexOffset + "\n");

        return code;
    }

    @Override
    public ArrayList<String> visitArrAsnVAR(TJBParser.ArrAsnVARContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        String arrID = ctx.name.getText();
        int indexOffset = singleton.getCheckUpTable().get(ctx.value).getNumberOnStack();

        String copyArrID = ctx.value.getText();
        int copyIndexOffset = singleton.getCheckUpTable().get(ctx.name).getNumberOnStack();

        code.add("\taload " + indexOffset);
        code.add("\tastore " + copyIndexOffset);

        return code;
    }

    /**
     * Visitor for when parentheses are used to increase the importance of a bit of code
     *
     * @param ctx ExParenthesesContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitExParentheses(TJBParser.ExParenthesesContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Add the code from within the parentheses.
        code.addAll(visit(ctx.calculation()));

        return code;
    }

    /**
     * Visit for when the value of a calculation, number or variable is negated.
     *
     * "-(2 * 10) -> A"
     *
     * @param ctx ExNegateContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitExNegate(TJBParser.ExNegateContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Add the code that comes after the negation.
        code.addAll(visit(ctx.calculation()));

        //Multiply by -1 to turn the result of the calculation from positive to negative or the other way around.
        // Also check the type so the right calculation is done for Jasmin not to crash.
        Type type = singleton.getCheckUpTable().get(ctx).getType();
        switch (type) {
            case INT:
                code.add("\tldc\t-1");
                code.add("\timul\n");
                break;
            case DOUBLE:
                code.add("\tldc\t-1.0");
                code.add("\tfmul\n");
                break;
        }

        return code;
    }

    /**
     * Visitor for when two values are being subtracted or added together.
     *
     * "(5 + 10) - A -> B"
     *
     * @param ctx ExAddContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @SuppressWarnings("Duplicates")
    @Override
    public ArrayList<String> visitExAddOp(TJBParser.ExAddOpContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Get the types of both values used in the calculation
        Type leftType = singleton.getCheckUpTable().get(ctx.left).getType();
        Type rightType = singleton.getCheckUpTable().get(ctx.right).getType();

        //Add all the code from the left side of the operator.
        code.addAll(visit(ctx.left));

        //Check what type of precision the calculation has to work with.
        if (leftType == Type.INT && rightType == Type.DOUBLE) {
            //Turn the left value into a float not to lose precision.
            code.add("\ti2f");
            leftType = Type.DOUBLE;
            code.addAll(visit(ctx.right));
        } else if (leftType == Type.DOUBLE && rightType == Type.INT) {
            //Turn the right value into a float not to loose precision.
            code.addAll(visit(ctx.right));
            code.add("\ti2f");
        } else {
            code.addAll(visit(ctx.right));
        }

        //Then add the correct code to add or subtract and for the right types, to not have Jasmin crash.
        switch (leftType) {
            case INT:
                code.add(ctx.op.getText().equals("+") ? "\tiadd\n" : "\tisub\n");
                break;
            case DOUBLE:
                code.add(ctx.op.getText().equals("+") ? "\tfadd\n" : "\tfsub\n");
                break;
        }

        return code;
    }

    /**
     * Visitor that's a lot like the previous one, only for divisions or multiplication
     *
     * "(5 * A) / 2 -> B"
     *
     * @param ctx ExMulDivOpContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @SuppressWarnings("Duplicates")
    @Override
    public ArrayList<String> visitExMulDivOp(TJBParser.ExMulDivOpContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Get the types of the two calculations used for this operation.
        Type leftType = singleton.getCheckUpTable().get(ctx.left).getType();
        Type rightType = singleton.getCheckUpTable().get(ctx.right).getType();

        //Add all the code from the left side of the operator
        code.addAll(visit(ctx.left));

        if (leftType == Type.INT && rightType == Type.DOUBLE) {
            //Turn the left value into a float not to lose precision.
            code.add("\ti2f");
            leftType = Type.DOUBLE;
            code.addAll(visit(ctx.right));
        } else if (leftType == Type.DOUBLE && rightType == Type.INT) {
            //Turn the right value into a float not to loose precision.
            code.addAll(visit(ctx.right));
            code.add("\ti2f");
        } else {
            code.addAll(visit(ctx.right));
        }

        //Then add the code to divide or multiply and for the correct number type as to not have Jasmin crash.
        switch (leftType) {
            case INT:
                code.add(ctx.op.getText().equals("*") ? "\timul\n" : "\tidiv\n");
                break;
            case DOUBLE:
                code.add(ctx.op.getText().equals("*") ? "\tfmul\n" : "\tfdiv\n");
                break;
        }

        return code;
    }

    /**
     * Visitor for the modulo operator.
     *
     * "10 % 5 -> A"
     *
     * @param ctx ExModOpContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @SuppressWarnings("Duplicates")
    @Override
    public ArrayList<String> visitExModOp(TJBParser.ExModOpContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Get the types of the left and right parts.
        Type leftType = singleton.getCheckUpTable().get(ctx.left).getType();
        Type rightType = singleton.getCheckUpTable().get(ctx.right).getType();

        //Add the code from the left side of the operator.
        code.addAll(visit(ctx.left));

        if (leftType == Type.INT && rightType == Type.DOUBLE) {
            //Turn the left value into a float not to lose precision.
            code.add("\ti2f");
            leftType = Type.DOUBLE;
            code.addAll(visit(ctx.right));
        } else if (leftType == Type.DOUBLE && rightType == Type.INT) {
            //Turn the right value into a float not to loose precision.
            code.addAll(visit(ctx.right));
            code.add("\ti2f");
        } else {
            code.addAll(visit(ctx.right));
        }

        //Then add the code to do the modulo calculation for the correct type, so Jasmin doesn't crash.
        switch (leftType) {
            case INT:
                code.add("\tirem\n");
                break;
            case DOUBLE:
                code.add("\tfrem\n");
                break;
        }

        return code;
    }

    /**
     * Visitor for when a variable has to be loaded, like when a variable is used in a calculation or call
     *
     * "Disp A, Str1"
     * OR, ETC
     * "A * 10 -> B"
     *
     * @param ctx ExVarLiteralContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitExVarLiteral(TJBParser.ExVarLiteralContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Get the index of the locals stack of the called variable.
        int indexOffset = singleton.getCheckUpTable().get(ctx.val).getNumberOnStack();

        //Get the value type of the variable being called.
        Type valueType = singleton.getCheckUpTable().get(ctx.val).getType();

        //Check the type to know what code to load for Jasmin. NOTE: Booleans are 0 or 1, therefore of type i.
        if (valueType.equals(Type.INT) || valueType.equals(Type.BOOLEAN)) {
            code.add("\tiload\t" + indexOffset);
        } else if (valueType.equals(Type.DOUBLE)) {
            code.add("\tfload\t" + indexOffset);
        } else if (valueType.equals(Type.STRING) || valueType.equals(Type.ARRAY)) {
            code.add("\taload\t" + indexOffset);
        }

        return code;
    }

    /**
     * Visitor for when a new double variable is called.
     *
     * @param ctx exDblLiteralContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitExDblLiteral(TJBParser.ExDblLiteralContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Add the code to load a double.
        code.add("\tldc\t" + ctx.DBL().getText());

        return code;
    }

    /**
     * Visitor for when a new negative number variable is called.
     *
     * @param ctx ExNegLiteralContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitExNegLiteral(TJBParser.ExNegLiteralContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Add the code to load the negative number.
        code.add("\tldc\t" + ctx.NIN().getText());

        return code;
    }

    /**
     * Visitor to add a normal integer to the code.
     *
     * @param ctx ExIntLiteralContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitExIntLiteral(TJBParser.ExIntLiteralContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Add the integer value onto the operand stack.
        code.add("\tldc\t" + ctx.INT().getText());

        return code;
    }

    /**
     * Visitor to add the parts of code for a boolean statement/comparison part. This boolean is in parentheses and
     *  therefore has a higher importance.
     *
     * @param ctx BoolParenthesesContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitBoolParentheses(TJBParser.BoolParenthesesContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Add the code from the boolean declared in the parentheses.
        code.addAll(visit(ctx.bool));

        return code;
    }

    /**
     * Visitor for the declaration of an if statement (branching)
     *
     * @param ctx ifTJBContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitIfTJB(TJBParser.IfTJBContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Get the sequence number for this branch to make it unique (and increase the counter for the next time).
        int ifNumber = ifSequence++;
        int localIfNumber = ifNumber;

        code.add("if_" + ifNumber + ":");
        //First add the if-statement
        code.addAll(visit(ctx.ifStatement()));

        localCurrentIf = localIfNumber;
        //Then any else-if-statements
        for (TJBParser.ElseIfStatementContext elseIfStatement : ctx.elseIfStatement()) {
            code.add("elseIf_" + localIfNumber + "-" + currentElseIf + ":");
            //Add all the expressions within the else-if statement
            code.addAll(visit(elseIfStatement));
            code.add("\tgoto\tallDone_" + localIfNumber);

            code.add("elseIfDone_" + localIfNumber + "-" + currentElseIf + ":");

            currentElseIf++;
        }
        //Reset the current else if again for the next generation of another else-if branch
        currentElseIf = 0;

        //And finally the else-statement, if there is one.
        if (ctx.elseStatement() != null) {
            code.add("else_" + ifNumber + ":");
            //Visit all the expressions in the else-statement.
            code.addAll(visit(ctx.elsePart));
            code.add("\tgoto\tallDone_" + ifNumber);
        }

        code.add("allDone_" + ifNumber + ":\n");

        return code;
    }

    /**
     * Visitor for the actual if-branch of an if-statement.
     *
     * @param ctx IfStatementContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitIfStatement(TJBParser.IfStatementContext ctx) {
        ArrayList<String> code = new ArrayList<>();
        //Get the right sequence number for your labels (already increased by IfTJB, so remove one here).
        int ifNumber = ifSequence - 1;

        //Add the boolean statement code to add 1 or 0 to the stack for our comparison.
        code.addAll(visit(ctx.bool));

        //Change the comparison to have the right label to it, checking if 1 to do the code or 0 to jump over.
        code.add("\tifeq\tifDone_" + ifNumber);

        //Add the actual code within the if-statement.
        code.addAll(visit(ctx.thenStatement()));
        code.add("\tgoto\tallDone_" + ifNumber);

        code.add("ifDone_" + ifNumber + ":");

        return code;
    }

    /**
     * Visitor that's almost exactly like the if-statement visitor, only for the else if parts.
     *
     * @param ctx ElseIfStatementContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitElseIfStatement(TJBParser.ElseIfStatementContext ctx) {
        ArrayList<String> code = new ArrayList<>();
        int currentIf = localCurrentIf;

        //Add the code from the boolean statement to have a 1 or a 0 onto the stack to know if we have to jump or not.
        code.addAll(visit(ctx.bool));

        //Change the comparison to have the right label to it.
        code.add("\tifeq\telseIfDone_" + currentIf + "-" + currentElseIf);

        //Add all the code declared within this else-if statement.
        code.addAll(visit(ctx.thenStatement()));

        return code;
    }

    /**
     * Visitor for the code in the final else statement to a branch, if there is one.
     *
     * @param ctx ElseStatementContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitElseStatement(TJBParser.ElseStatementContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Add all the code declared within the else statement.
        for (TJBParser.ExpressionContext expressionContext : ctx.expression()) {
            code.addAll(visit(expressionContext));
        }

        return code;
    }

    /**
     * Visitor to get all the code in the if or else-if statements, after the "Then" part.
     *
     * @param ctx ThenStatementContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitThenStatement(TJBParser.ThenStatementContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Add all the code after the "Then" and before the "End" for this branch.
        for (TJBParser.ExpressionContext expressionContext : ctx.expression()) {
            code.addAll(visit(expressionContext));
        }

        return code;
    }

    /**
     * Visitor for when the negation character for booleans ("!") is used.
     *
     * "!(5 < 10)"
     *
     * @param ctx BoolNegContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitBoolNeg(TJBParser.BoolNegContext ctx) {
        ArrayList<String> code = new ArrayList<>();
        //We want the negation to have the same number for the labels as the actual comparison, just to make the reading of the Jasmin a bit easier.
        int negCompNumber = compSequence;

        //Add all the code from the boolean in question, to have either 1 or 0 put on the stack here.
        code.addAll(visit(ctx.bool));

        code.add("\tifeq\tnegPos_" + negCompNumber);
        //If the number is not 0 (which means it's 1 (true), since we're negating a boolean), we need to make it 0 (false).
        code.add("\tldc\t0");
        code.add("\tgoto\tnegDone_" + negCompNumber);

        //In this case, the number on the stack is 0 (false), and we need to make it 1 (true).
        code.add("negPos_" + negCompNumber + ":");
        code.add("\tldc\t1");

        //This is so that in the true to false case, we do not perform the false to true case too.
        code.add("negDone_" + negCompNumber + ":\n");

        return code;
    }

    /**
     * Visitor for any boolean comparisons used, for instance in loops and branching.
     *
     * @param ctx BoolCompContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @SuppressWarnings("Duplicates")
    @Override
    public ArrayList<String> visitBoolComp(TJBParser.BoolCompContext ctx) {
        ArrayList<String> code = new ArrayList<>();
        //Get the next number in the sequence to keep this comparison readable and unique for Jasmin.
        int compNumber = compSequence++;

        //Get the comparison tokens in question.
        String comparisonToken = ctx.comp.getText();

        //Get the type of the left and right variable of the comparison tokens.
        Type leftType = singleton.getCheckUpTable().get(ctx.left).getType();
        Type rightType = singleton.getCheckUpTable().get(ctx.right).getType();

        //Add all the code from the left side of the comparison token.
        code.addAll(visit(ctx.left));

        if (leftType == Type.INT && rightType == Type.DOUBLE) {
            //Turn the left value into a float not to lose precision.
            code.add("\ti2f");
            leftType = Type.DOUBLE;
            code.addAll(visit(ctx.right));
        } else if (leftType == Type.DOUBLE && rightType == Type.INT) {
            //Turn the right value into a float not to loose precision.
            code.addAll(visit(ctx.right));
            code.add("\ti2f");
        } else {
            code.addAll(visit(ctx.right));
        }

        switch (comparisonToken) {
            case "<":
                if (leftType == Type.INT) {
                    //We want to jump to the label if left is greater or equal to right.
                    code.add("\tif_icmpge\t");
                } else {
                    //If value 1 (left) is SMALLER THAN value 2 (right) we should get int 1 as a result.
                    code.add("\tfcmpl");
                    //We want to jump to the label only if the int is -1 or 0 (meaning value 1 is BIGGER THAN or EQUAL TO value 2)
                    code.add("\tifle\t");
                }
                break;
            case "<=":
                if (leftType == Type.INT) {
                    //We want to jump to the label only if left is greater than right.
                    code.add("\tif_icmpgt\t");
                } else {
                    //If value 1 (left) is SMALLER THAN value 2 (right) we should get int 1 (less) or 0 (equal) as a result.
                    code.add("\tfcmpl");
                    //We want to jump to the label only if the int is -1 (meaning value 1 is BIGGER THAN value 2)
                    code.add("\tiflt\t");
                }
                break;
            case "=":
                if (leftType == Type.INT) {
                    //We want to jump to the label if left is not equal to right.
                    code.add("\tif_icmpne\t");
                } else {
                    //If value 1 (left) is EQUAL TO value 2 (right) we should get int 0 as a result.
                    code.add("\tfcmpl");
                    //We want to jump to the label only if the int is -1 or 1 (meaning value 1 is BIGGER THAN or SMALLER THAN value 2)
                    code.add("\tifne\t");
                }
                break;
            case "!=":
                if (leftType == Type.INT) {
                    //We want to jump to the label if left is not equal to right.
                    code.add("\tif_icmpeq\t");
                } else {
                    //If value 1 (left) is NOT EQUAL TO value 2 (right) we should get int -1 or 1 as a result.
                    code.add("\tfcmpl");
                    //We want to jump to the label only if the int is 0 (meaning value 1 is EQUAL TO value 2)
                    code.add("\tifeq\t");
                }
                break;
            case ">":
                if (leftType == Type.INT) {
                    //We want to jump to the label if left is smaller than or equal to right.
                    code.add("\tif_icmple\t");
                } else {
                    //If value 1 (left) is BIGGER THAN value 2 (right) we should get int 1 as a result.
                    code.add("\tfcmpg");
                    //We want to jump to the label only if the int is 0 or -1 (meaning value 1 is SMALLER THAN or EQUAL TO value 2)
                    code.add("\tifle\t");
                }
                break;
            case ">=":
                if (leftType == Type.INT) {
                    //We want to jump to the label if left is smaller than right.
                    code.add("\tif_icmplt\t");
                } else {
                    //If value 1 (left) is BIGGER THAN or EQUAL TO value 2 (right) we should get int 1 or 0 as a result.
                    code.add("\tfcmpg");
                    //We want to jump to the label only if the int is -1 (meaning value 1 is SMALLER THAN value 2)
                    code.add("\tiflt\t");
                }
                break;
        }

        //Add the label for the comparison to jump to if it is false.
        code.set((code.size() - 1), code.get(code.size() - 1) + "compNeg_" + compNumber);
        //We'll end up here and add a one if the comparison is true.
        code.add("\tldc\t1");
        code.add("\tgoto\tcompDone_" + compNumber);

        //The comparison is false, so return a 0.
        code.add("compNeg_" + compNumber + ":");
        code.add("\tldc\t0");

        //End statement for the true to jump to, as to not perform the false code.
        code.add("compDone_" + compNumber + ":\n");

        return code;
    }

    /**
     * Visitor for when a logic gate is used with the boolean comparisons.
     *
     * "5 < A || 10 >= B"
     * OR
     * "C = 12 && 50 != D"
     *
     * @param ctx BoolCompLogContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitBoolCompLog(TJBParser.BoolCompLogContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        String comparisonToken = ctx.comp.getText();

        //Add all the code of the left and right comparison, this should leave two integers of either 1 or 0 each on top of the operand stack right before here.
        code.addAll(visit(ctx.left));

        if (comparisonToken.equalsIgnoreCase("||") || comparisonToken.equalsIgnoreCase("Or")) {
            int orNumber = orLogicSequence++;

            //This is the "Or" (or "||") logic gate.
            //If the number on the stack from the first boolean is 1 or more (true), go to label. If 0 or less (false), go to the right code, as that might still be true.
            code.add("\tifgt\tlogicOr_" + orNumber);
            code.addAll(visit(ctx.right));
            code.add("\tgoto\tlogicOrEnd_" + orNumber);

            //If left is true though, we can just immediately push true on the stack (short circuit) so that the branch or loop can do an iteration.
            code.add("logicOr_" + orNumber + ":");
            code.add("\tldc\t1");

            code.add("logicOrEnd_" + orNumber + ":");
        } else {
            int andNumber = andLogicSequence++;

            //This is the "And" (or "&&") logic gate.
            //If the number on the stack from the first boolean is 1 or more (true), go to label. If 0 or less (false), put 0 on the stack, as the right comparison doesn't even have to be looked at (short circuit).
            code.add("\tifgt\tlogicAnd_" + andNumber);
            code.add("\tldc\t0");
            code.add("\tgoto\tlogicAndEnd_" + andNumber);

            //If left is true, then right also has to be run, and if that returns true or false will dictate if the loop or branch will run.
            code.add("logicAnd_" + andNumber + ":");
            code.addAll(visit(ctx.right));

            code.add("logicAndEnd_" + andNumber + ":");
        }

        return code;
    }

    /**
     * Visitor for when a while loop is used in the code.
     *
     * "While A < 10"
     * "    Disp A"
     * "    A + 1 --> A"
     * "End"
     *
     * @param ctx WhileTJBContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitWhileTJB(TJBParser.WhileTJBContext ctx) {
        ArrayList<String> code = new ArrayList<>();
        //Get the next sequence number to make the code readable and the labels unique for Jasmin.
        int whileNumber = whileSequence++;

        code.add("while_" + whileNumber + ":");

        //Add the boolean comparison to get 1 or 0 onto the stack for our while condition.
        code.addAll(visit(ctx.bool));

        //Change the comparison to have the right label to it.
        code.add("\tifeq\twhileDone_" + whileNumber);

        //Add all the code within the while loop
        for (TJBParser.ExpressionContext expressionContext : ctx.expression()) {
            code.addAll(visit(expressionContext));
        }

        code.add("\tgoto\twhile_" + whileNumber);
        //---
        code.add("whileDone_" + whileNumber + ":");

        return code;
    }

    /**
     * Visitor for the for-loop and the code around that.
     *
     * "For (A, 0, A < 5, A += 1)"
     * "    Disp A"
     * "End"
     *
     * @param ctx ForTJBContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitForTJB(TJBParser.ForTJBContext ctx) {
        ArrayList<String> code = new ArrayList<>();
        //Get the next number for this for loop, as to make the code readable and the label unique for Jasmin.
        int forNumber = forSequence++;

        //Get the type of the defined iterator and get its number on the locals list to get it.
        Type iteratorType = singleton.getCheckUpTable().get(ctx.iterator).getType();
        String varID = ctx.iterator.getText();
        int indexOffset = singleton.getCheckUpTable().get(ctx.iterator).getNumberOnStack();

        if (indexOffset > variables.size()) {
            //The variable doesn't exist yet, so add it!
            variables.add(varID);
            indexOffset = variables.size();

            code.add("\tldc\t" + ctx.iterVal.getText());

            if (iteratorType == Type.INT) {
                //Value given is an integer.
                code.add("\tistore\t" + indexOffset);
            } else {
                //The value given is a double.
                code.add("\tfstore\t" + indexOffset);
            }
        } else {
            //The variable already exists, but the user wants to set a new value to it.
            //If the iterVal is being left empty, we just use the value already stored on the given var.
            if (ctx.iterVal != null && !ctx.iterVal.getText().isEmpty()) {
                //If there is a new value given, then store it onto the variable (typechecker enforces that both the var and new value are of the same type)
                code.add("\tldc\t" + ctx.iterVal.getText());

                if (iteratorType == Type.INT) {
                    //Value given is an integer.
                    code.add("\tistore\t" + indexOffset);
                } else {
                    //The value given is a double.
                    code.add("\tfstore\t" + indexOffset);
                }
            }
        }

        code.add("for_" + forNumber + ":");

        //Now do the comparison to see if we have to do the next loop or not.
        code.addAll(visit(ctx.comp));

        //Change the comparison to have the right label to it.
        code.add("\tifeq\tforDone_" + forNumber);

        for (TJBParser.ExpressionContext expressionContext : ctx.expression()) {
            code.addAll(visit(expressionContext));
        }

        //Perform the increments on the var given.
        code.addAll(visit(ctx.increments));

        code.add("\tgoto\tfor_" + forNumber);
        //---
        code.add("forDone_" + forNumber + ":\n");

        return code;
    }

    /**
     * Visitor for the for-loop's incrementer at the end of the requirements for the for-loop.
     *
     * "..., A += 1)"
     *
     * @param ctx IncrementEXPContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitIncrementEXP(TJBParser.IncrementEXPContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //We don't have to check if the Var exists, as the typechecker should make sure the var given here is the same one declared earlier in the for-loop
        Type iteratorType = singleton.getCheckUpTable().get(ctx.nameVar).getType();
        int indexOffset = singleton.getCheckUpTable().get(ctx.nameVar).getNumberOnStack();

        //Load the var, as we need to add the result of the calculation to that at the end.
        if (iteratorType == Type.INT) {
            //Value given is an integer.
            code.add("\tiload\t" + indexOffset);
        } else {
            //The value given is a double.
            code.add("\tfload\t" + indexOffset);
        }

        //Do the calculation given.
        code.addAll(visit(ctx.calc));

        //Then add the result of the calculation to the var and store the result onto the var.
        if (iteratorType == Type.INT) {
            //Value given is an integer.
            code.add("\tiadd");
            code.add("\tistore\t" + indexOffset + "\n");
        } else {
            //The value given is a double.
            code.add("\tfadd");
            code.add("\tfstore\t" + indexOffset + "\n");
        }

        return code;
    }

    /**
     * Visitor for a comment line added to the code.
     *
     * "<COM> "Comment text here" </COM>"
     *
     * @param ctx CommentLineContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitCommentLine(TJBParser.CommentLineContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Add the text written in the comment to an actual Jasmin comment in the code.
        code.add("\t;\t" + ctx.STR().getText());

        return code;
    }

    private boolean newLine = false;

    /**
     * Visitor for the display command to output things on the screen.
     *
     * "Disp A, "Hello world", Str1"
     *
     * @param ctx DisplayContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitDisplay(TJBParser.DisplayContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Check if it needs to be printed on a new line or not.
        newLine = !ctx.line.getText().equals("Dispn");
        //Add all the things the user wants to print on the screen.
        for (TJBParser.DisplayOptionsContext displayOptions : ctx.displayOptions()) {
            code.addAll(visit(displayOptions));
        }

        return code;
    }

    /**
     * Visitor when the user wants to plainly print a String (So not a string variable!)
     *
     * "Disp "Hello world""
     *
     * @param ctx DispSTRContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitDispSTR(TJBParser.DispSTRContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        //Add the declaration of wanting to use the out printstream and then the text to print.
        code.add("\tgetstatic\tjava/lang/System/out\tLjava/io/PrintStream;");
        code.add("\tldc\t" + ctx.STR().getText());

        if (newLine) {
            //The user wants it printed on a new line (by using "Dispn")
            code.add("\tinvokevirtual\tjava/io/PrintStream/println(Ljava/lang/String;)V\n");
        } else {
            //The user wants the thing printed not on a new line but on the current line (by using "Disp")
            code.add("\tinvokevirtual\tjava/io/PrintStream/print(Ljava/lang/String;)V\n");
        }


        return code;
    }

    /**
     * Visitor for when the user wants to print the String stored on a String variable, otherwise exactly like a normal string print.
     *
     * "Disp Str1"
     *
     * @param ctx DispSTRIDContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitDispSTRID(TJBParser.DispSTRIDContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        code.add("\tgetstatic\tjava/lang/System/out\tLjava/io/PrintStream;");

        //Get the number of the string to load from the locals stack (this is the String variable).
        int indexOffset = singleton.getCheckUpTable().get(ctx.name).getNumberOnStack();

        code.add("\taload\t" + indexOffset);
        if (newLine) {
            code.add("\tinvokevirtual\tjava/io/PrintStream/println(Ljava/lang/String;)V\n");
        } else {
            code.add("\tinvokevirtual\tjava/io/PrintStream/print(Ljava/lang/String;)V\n");
        }

        return code;
    }

    /**
     * Visitor for when the user wants to print a number, result of a calculation or number variable.
     *
     * "Disp A, 5, 5 + 10"
     *
     * @param ctx DispCalcContext is the context of the current node.
     * @return code ArrayList<String> is the code generated by the code generator in this visit.
     */
    @Override
    public ArrayList<String> visitDispCalc(TJBParser.DispCalcContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        code.add("\tgetstatic\tjava/lang/System/out\tLjava/io/PrintStream;");
        code.addAll(visit(ctx.calculation()));

        //Get the type of the calculation at hand so we can tell jasmin what type of print to call.
        Type type = singleton.getCheckUpTable().get(ctx).getType();
        switch (type) {
            case INT:
                //The calculation/variable results in an int.
                if (newLine) {
                    code.add("\tinvokevirtual\tjava/io/PrintStream/println(I)V\n");
                } else {
                    code.add("\tinvokevirtual\tjava/io/PrintStream/print(I)V\n");
                }
                break;
            case DOUBLE:
                //The calculation/variable results in an double
                if (newLine) {
                    code.add("\tinvokevirtual\tjava/io/PrintStream/println(F)V\n");
                } else {
                    code.add("\tinvokevirtual\tjava/io/PrintStream/print(F)V\n");
                }
                break;
        }

        return code;
    }

    @Override
    public ArrayList<String> visitDispArray(TJBParser.DispArrayContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        Type arrayType = singleton.getCheckUpTable().get(ctx.name).getType();
        int indexOffset = singleton.getCheckUpTable().get(ctx.name).getNumberOnStack();

        code.add("\tgetstatic\tjava/lang/System/out\tLjava/io/PrintStream;");
        code.add("\taload\t" + indexOffset);

        if (arrayType == Type.INTARRAY) {
            code.add("\tinvokestatic\tjava/util/Arrays/toString([I)Ljava/lang/String;");
        } else if (arrayType == Type.STRINGARRAY) {
            code.add("\tinvokestatic\tjava/util/Arrays/toString([Ljava/lang/Object;)Ljava/lang/String;");
        } else if (arrayType == Type.DOUBLEARRAY) {
            code.add("\tinvokestatic\tjava/util/Arrays/toString([F)Ljava/lang/String;");
        }
        if (newLine) {
            code.add("\tinvokevirtual\t java/io/PrintStream/println(Ljava/lang/String;)V");
        } else {
            code.add("\tinvokevirtual\t java/io/PrintStream/print(Ljava/lang/String;)V");
        }
        return code;
    }

    @Override
    public ArrayList<String> visitScannerAsn(TJBParser.ScannerAsnContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        variables.add(ctx.name.getText());

        int indexOffset = variables.size();

        code.add("\tnew\t" + "\tjava/util/Scanner\t");
        code.add("\tdup\t");
        code.add("\tgetstatic\t" + "\tjava/lang/System/in Ljava/io/InputStream;\t");
        code.add("\tinvokespecial\t" + "\tjava/util/Scanner/<init>(Ljava/io/InputStream;)V\t");
        code.add("\tastore_" + indexOffset);

        return code;
    }

    @Override
    public ArrayList<String> visitScannerCls(TJBParser.ScannerClsContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        int indexOffset = singleton.getCheckUpTable().get(ctx.scnr).getNumberOnStack();

        code.add("\taload_" + indexOffset);
        code.add("\tinvokevirtual\t" + "java/util/Scanner/close()V");

        return code;
    }

    @Override
    public ArrayList<String> visitStrAsnUsrIn(TJBParser.StrAsnUsrInContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        variables.add(ctx.name.getText());

        int place = variables.size();
        int indexOffset = singleton.getCheckUpTable().get(ctx.scnr).getNumberOnStack();

        code.add("\tgetstatic\tjava/lang/System/out\tLjava/io/PrintStream;");
        code.add("\tldc\t" + '"' + "Please type a string." + '"');
        code.add("\tinvokevirtual\tjava/io/PrintStream/println(Ljava/lang/String;)V\n");

        code.add("\taload_" + indexOffset);
        code.add("\tinvokevirtual\t" + "java/util/Scanner/nextLine()Ljava/lang/String;");
        code.add("\tastore " + place);

        return code;
    }

    @Override
    public ArrayList<String> visitStrAsnUsrInVAR(TJBParser.StrAsnUsrInVARContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        int indexOffset = singleton.getCheckUpTable().get(ctx.scnr).getNumberOnStack();
        int numberIndexOffset = singleton.getCheckUpTable().get(ctx.name).getNumberOnStack();

        code.add("\tgetstatic\tjava/lang/System/out\tLjava/io/PrintStream;");
        code.add("\tldc\t" + '"' + "Please type a string." + '"');
        code.add("\tinvokevirtual\tjava/io/PrintStream/println(Ljava/lang/String;)V\n");

        code.add("\taload_" + indexOffset);
        code.add("\tinvokevirtual\t" + "java/util/Scanner/nextLine()Ljava/lang/String;");
        code.add("\tastore " + numberIndexOffset);

        return code;
    }

    @Override
    public ArrayList<String> visitNumAsnUsrInt(TJBParser.NumAsnUsrIntContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        variables.add(ctx.name.getText());

        int place = variables.size();
        int indexOffset = singleton.getCheckUpTable().get(ctx.scnr).getNumberOnStack();

        code.add("\tgetstatic\tjava/lang/System/out\tLjava/io/PrintStream;");
        code.add("\tldc\t" + '"' + "Please type a number." + '"');
        code.add("\tinvokevirtual\tjava/io/PrintStream/println(Ljava/lang/String;)V\n");

        code.add("\taload_" + indexOffset);
        code.add("\tinvokevirtual\t" + "java/util/Scanner/nextInt()I");
        code.add("\tistore " + place);
        return code;
    }

    @Override
    public ArrayList<String> visitNumAsnUsrIntVAR(TJBParser.NumAsnUsrIntVARContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        int indexOffset = singleton.getCheckUpTable().get(ctx.scnr).getNumberOnStack();
        int numberIndexOffset = singleton.getCheckUpTable().get(ctx.name).getNumberOnStack();

        code.add("\tgetstatic\tjava/lang/System/out\tLjava/io/PrintStream;");
        code.add("\tldc\t" + '"' + "Please type a number." + '"');
        code.add("\tinvokevirtual\tjava/io/PrintStream/println(Ljava/lang/String;)V\n");

        code.add("\taload_" + indexOffset);
        code.add("\tinvokevirtual\t" + "java/util/Scanner/nextInt()I");
        if (singleton.getCheckUpTable().get(ctx.name).getType() == Type.DOUBLE) {
            code.add("\ti2f\t");
            code.add("\tfastore " + numberIndexOffset);
        } else {
            code.add("\tistore " + numberIndexOffset);
        }

        return code;
    }

    @Override
    public ArrayList<String> visitNumAsnUsrDbl(TJBParser.NumAsnUsrDblContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        variables.add(ctx.name.getText());

        int place = variables.size();
        int indexOffset = singleton.getCheckUpTable().get(ctx.scnr).getNumberOnStack();

        code.add("\tgetstatic\tjava/lang/System/out\tLjava/io/PrintStream;");
        code.add("\tldc\t" + '"' + "Please type a number." + '"');
        code.add("\tinvokevirtual\tjava/io/PrintStream/println(Ljava/lang/String;)V\n");

        code.add("\taload_" + indexOffset);
        code.add("\tinvokevirtual\t" + "java/util/Scanner/nextFloat()F");
        code.add("\tinvokestatic\t" + "java/lang/Float/valueOf(F)Ljava/lang/Float;");
        code.add("\tinvokevirtual " + "java/lang/Float/floatValue()F");
        code.add("\tfstore " + place);

        return code;
    }

    @Override
    public ArrayList<String> visitNumAsnUsrDblVAR(TJBParser.NumAsnUsrDblVARContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        int indexOffset = singleton.getCheckUpTable().get(ctx.scnr).getNumberOnStack();
        int numberIndexOffset = singleton.getCheckUpTable().get(ctx.name).getNumberOnStack();

        code.add("\tgetstatic\tjava/lang/System/out\tLjava/io/PrintStream;");
        code.add("\tldc\t" + '"' + "Please type a number." + '"');
        code.add("\tinvokevirtual\tjava/io/PrintStream/println(Ljava/lang/String;)V\n");

        code.add("\taload_" + indexOffset);
        code.add("\tinvokevirtual\t" + "java/util/Scanner/nextFloat()F");
        code.add("\tinvokestatic\t" + "java/lang/Float/valueOf(F)Ljava/lang/Float;");
        code.add("\tinvokevirtual " + "java/lang/Float/floatValue()F");
        code.add("\tfstore " + numberIndexOffset);

        return code;
    }

    //Get value from array.


    @Override
    public ArrayList<String> visitExArrLiteral(TJBParser.ExArrLiteralContext ctx) {
        ArrayList<String> code = new ArrayList<>();
        code.addAll(visit(ctx.arrayGetValue()));
        Type typeOfValue = singleton.getCheckUpTable().get(ctx).getType();
        if (typeOfValue == Type.INT) {
            code.add("\tiaload\t");
        } else if (typeOfValue == Type.DOUBLE) {
            code.add("\tfaload\t");
        }
        return code;
    }

    @Override
    public ArrayList<String> visitArrayGetValue(TJBParser.ArrayGetValueContext ctx) {
        ArrayList<String> code = new ArrayList<>();
        int arrayPosition = singleton.getCheckUpTable().get(ctx.arrayName).getNumberOnStack();
        String valuePosition = ctx.number.getText();

        code.add("\taload\t" + arrayPosition);
        code.add("\tldc\t" + valuePosition);
        return code;
    }

    @Override
    public ArrayList<String> visitAsnArrVal(TJBParser.AsnArrValContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        Type typeOfArray = singleton.getCheckUpTable().get(ctx.name).getType();

        code.addAll(visit(ctx.name));
        code.addAll(visit(ctx.value));

        if (typeOfArray == Type.INT) {
            code.add("\tiastore\n");
        } else if (typeOfArray == Type.DOUBLE) {
            if (!ctx.value.getText().contains(".")) {
                code.add("\ti2f\t");
            }
            code.add("\tfastore\n");
        }
        return code;
    }

    @Override
    @SuppressWarnings("Duplicates")
    public ArrayList<String> visitAsnStrFromArr(TJBParser.AsnStrFromArrContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        String strID = ctx.name.getText();
        variables.add(strID);
        int indexOffset = singleton.getCheckUpTable().get(ctx.name).getNumberOnStack();

        code.addAll(visit(ctx.value));
        code.add("\taaload\t");

        code.add("\tastore\t" + indexOffset + "\n");

        return code;
    }

    @Override
    @SuppressWarnings("Duplicates")
    public ArrayList<String> visitCpyAsnStrFromArr(TJBParser.CpyAsnStrFromArrContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        String strID = ctx.name.getText();
        int indexOffset = singleton.getCheckUpTable().get(ctx.name).getNumberOnStack();

        code.addAll(visit(ctx.value));
        code.add("\taaload\t");

        code.add("\tastore\t" + indexOffset + "\n");

        return code;
    }

    @Override
    public ArrayList<String> visitStrArrValUsrIn(TJBParser.StrArrValUsrInContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        int indexOffset = singleton.getCheckUpTable().get(ctx.scnr).getNumberOnStack();
        int numberIndexOffset = singleton.getCheckUpTable().get(ctx.name).getNumberOnStack();

        code.add("\tgetstatic\tjava/lang/System/out\tLjava/io/PrintStream;");
        code.add("\tldc\t" + '"' + "Please type a string." + '"');
        code.add("\tinvokevirtual\tjava/io/PrintStream/println(Ljava/lang/String;)V\n");

        code.addAll(visit(ctx.name));

        code.add("\taload_" + indexOffset);
        code.add("\tinvokevirtual\t" + "java/util/Scanner/nextLine()Ljava/lang/String;");
        code.add("\taastore\t");

        return code;
    }

    @Override
    public ArrayList<String> visitIntArrValUsrIn(TJBParser.IntArrValUsrInContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        int place = variables.size();
        int indexOffset = singleton.getCheckUpTable().get(ctx.scnr).getNumberOnStack();

        code.add("\tgetstatic\tjava/lang/System/out\tLjava/io/PrintStream;");
        code.add("\tldc\t" + '"' + "Please type a number." + '"');
        code.add("\tinvokevirtual\tjava/io/PrintStream/println(Ljava/lang/String;)V\n");

        code.addAll(visit(ctx.name));

        code.add("\taload_" + indexOffset);
        code.add("\tinvokevirtual\t" + "java/util/Scanner/nextInt()I");
        if (singleton.getCheckUpTable().get(ctx.name).getType() == Type.DOUBLE) {
            code.add("\ti2f\t");
            code.add("\tfastore\t");
        } else {
            code.add("\tiastore\t");
        }
        return code;
    }

    @Override
    public ArrayList<String> visitDblArrValUsrIn(TJBParser.DblArrValUsrInContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        int place = variables.size();
        int indexOffset = singleton.getCheckUpTable().get(ctx.scnr).getNumberOnStack();

        code.add("\tgetstatic\tjava/lang/System/out\tLjava/io/PrintStream;");
        code.add("\tldc\t" + '"' + "Please type a number." + '"');
        code.add("\tinvokevirtual\tjava/io/PrintStream/println(Ljava/lang/String;)V\n");

        code.addAll(visit(ctx.name));

        code.add("\taload_" + indexOffset);
        code.add("\tinvokevirtual\t" + "java/util/Scanner/nextFloat()F");
        code.add("\tinvokestatic\t" + "java/lang/Float/valueOf(F)Ljava/lang/Float;");
        code.add("\tinvokevirtual " + "java/lang/Float/floatValue()F");

        code.add("\tfastore\t");

        return code;
    }

    @Override
    public ArrayList<String> visitStrArrAsnVar(TJBParser.StrArrAsnVarContext ctx) {
        ArrayList<String> code = new ArrayList<>();
        int copyIndexOffset = singleton.getCheckUpTable().get(ctx.value).getNumberOnStack();

        code.addAll(visit(ctx.name));
        code.add("\taload\t" + copyIndexOffset);
        code.add("\taastore\t");
        return code;
    }

    @Override
    public ArrayList<String> visitStrArrAsn(TJBParser.StrArrAsnContext ctx) {
        ArrayList<String> code = new ArrayList<>();

        code.addAll(visit(ctx.name));
        code.add("\tldc\t" + ctx.value.getText());
        code.add("\taastore\t");
        return code;
    }
}
